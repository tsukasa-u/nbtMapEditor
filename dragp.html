<!DOCTYPE html>
<html lang=en>
<head>
  <title>NBT</title>
  <style>
    /* div {
      margin: 0em;
      padding: 2em;
      border-radius: 30px;
      margin-left: auto;
      margin-right: auto;
    } */
    p, h1, h2, #centerArea {
      color: #999;
      text-align: center;
    }
    #canvas {
      width:  128px;
      height: 128px;
      margin: 0em;
      padding: 2em;
      border-radius: 30px;
      border: 5px solid #ccc;
      display: block;
      /* position: absolute; */
      right: 0;
      left: 0;
      margin: auto;
    }
    #nbt_zone {
      overflow: hidden;
      border: 5px solid #ccc;
      border-radius: 30px;
      padding: 2em;
      width:  648px;
      height: 400px;
      margin-left: auto;
      margin-right: auto;
    }

  </style>
</head>
<body>
    <!-- <div>
        <h1>Drag and drop files</h1>
  
        <div id="drop_zone" ondrop="dropHandlerImage(event);" ondragover="dragOverHandlerImage(event);">
          <p>Drag image file and map.dat file to this Drop Zone ...</p>
        </div>
    </div> -->
    <div>
      <h2>image</h2>
      <canvas id="canvas" ondrop="dropHandlerImage(event);" ondragover="dragOverHandlerImage(event);"></canvas>
    </div>
    <div>
      <h2>nbt</h2>
      <div id="nbt_zone" ondrop="dropHandlerNBT(event);" ondragover="dragOverHandlerNBT(event);"></div>
    </div>
    <div id="centerArea">
      <h2>file download</h2>
      <a id="download_button" href="#" download="test.txt">DOWNLOAD NBT ZIPED FILE</a>
    </div>
  
    <script type="text/javascript" src="./zlib.js-develop/bin/gunzip.min.js"></script>
    <script type="text/javascript" src="./zlib.js-develop/bin/gzip.min.js"></script>
    <script type="text/javascript" src="./json-view-master/dist/jsonview.js"></script>
    <script type="text/javascript">

    let colorBaseMap = [
      [0, 0, 0],
      [127, 178, 56],
      [247, 233, 163],
      [167, 167, 167],
      [255, 0, 0],
      [160, 160, 255],
      [167, 167, 167],
      [0, 124, 0],
      [255, 255, 255],
      [164, 168, 184],
      [183, 106, 47],
      [112, 112, 112],
      [64, 64, 255],
      [104, 83, 50],
      [255, 252, 245],
      [216, 127, 51],
      [178, 76, 216],
      [102, 153, 216],
      [229, 229, 51],
      [127, 204, 25],
      [242, 127, 165],
      [76, 76, 76],
      [153, 153, 153],
      [76, 127, 153],
      [127, 63, 178],
      [51, 76, 178],
      [102, 76, 51],
      [102, 127, 51],
      [153, 51, 51],
      [25, 25, 25],
      [250, 238, 77],
      [92, 219, 213],
      [74, 128, 255],
      [0, 217, 58],
      [21, 20, 31],
      [112, 2, 0],
      [126, 84, 48]
    ];
    
    let RGB2XYZ = [
      [0.412453, 0.35758, 0.180423],
      [0.212671, 0.71516, 0.0721688],
      [0.0193338, 0.119194, 0.950227]
    ];


    // let XYZ2RGB = [
    //   3.240479, -1.537150, -0.498535,
    //   -0.969256,  1.875991,  0.041556,
    //   0.055648, -0.204043,  1.057311
    // ];

    let D65 = {
      Xn: 95.0489,
      Yn: 100.0,
      Zn: 108.8840
    };

    let colorMap = [colorBaseMap.length*4].map((element, index) => {
      let colorIndex = Math.floor(index/4);
      let ret;
      switch (index%4) {
        case 0:
          ret = colorBaseMap[colorIndex].map((ele) => ele*180.0/255.0+0.5);
          break;
        case 1:
          ret = colorBaseMap[colorIndex].map((ele) => ele*220.0/255.0+0.5);
          break;
        case 2:
          ret = colorBaseMap[colorIndex].map((ele) => ele                );
          break;
        case 3:
          ret = colorBaseMap[colorIndex].map((ele) => ele*135.0/255.0+0.5);
      }
      return ret;
    }, 0);
    
    function RGB2LAB(rgb) {
      
      const f = (t) => {
        if (t>0.008856) {
          return Math.pow(t, 1/3);
        } else {
          return 7.787037*t + 4/29;
        }
      }

      let color3 = rgb.slice(0,3);
      let xyz = RGB2XYZ.map((element) => element[0]*color3[0] + element[1]*color3[1] + element[2]*color3[2]);
      let LStar = 116*f(xyz[1]/D65[Yn]) - 16;
      let aStar = 500*(f(xyz[0]/D65[Xn]) - f(xyz[1]/D65[Yn]));
      let bStar = 200*(f(xyz[1]/D65[Yn]) - f(xyz[2]/D65[Zn]));
      let CStar = Math.sqrt(aStar*aStar + bStar*bStar);
      let hCircle = Math.atan(bStar/aStar);
      return [LStar, aStar, bStar, CStar, hCircle];
    }

    function CIE2000(labch1, labch2, kL=1, kC=1, kH=1) {
      let DeltaL = labch2[0] - labch1[0];
      let L_ = (labch2[0] + labch1[0])/2;
      let DeltaC = labch2[3] - labch1[3];
      let C_ = (labch2[3] + labch1[3])/2; 
      let a1p = labch1[1] + labch1[1]/2*(1 - Math.sqrt(Math.pow(C_, 7)/(Math.pow(C_, 7) + Math.pow(25, 7))));
      let a2p = labch2[1] + labch2[1]/2*(1 - Math.sqrt(Math.pow(C_, 7)/(Math.pow(C_, 7) + Math.pow(25, 7))));
      let Deltah;
      if (Math.abs(labch2[4] - labch1[4]) <= Math.PI) {
        Deltah = labch2[4] - labch1[4];
      } else {
        if (labch2[4] <= labch1[4]){
          Deltah = labch2[4] - labch1[4] + 2*Math.PI;
        } else {
          Deltah = labch2[4] - labch1[4] - 2*Math.PI;
        }
      }
      let DeltaH = 2*Math.sqrt(labch2[3]*labch1[3])*Math.sin(Deltah/2);
      let H_;
      if (Math.abs(labch2[4] - labch1[4]) <= Math.PI) {
        H_ = (labch2[4] + labch1[4])/2;
      } else {
        H_ = (labch2[4] + labch1[4] + 2*Math.PI)/2;
      }
      let T = 1 - 0.17*Math.cos(H_ - Math.PI/6) + 0.24*Math.cos(2*H_) + 0.32*Math.cos(3*H_ + Math.PI/30) - 0.20*cos(4*H_ - 0.35*Math.PI);
      let SL = 1 + 0.015*Math.pow(L_ - 50, 2)/Math.sqrt(20 + Math.pow(L_ - 50, 2));
      let SC = 1 + 0.045*C_;
      let SH = 1 + 0.015*C_*T;
      let RT = -2*Math.sqrt(Math.pow(C_, 7)/(Math.pow(C_, 7) + Math.pow(25, 7)))*Math.sin(Math.PI/3*Math.exp(-Math.pow((H_ - 275/180*Math.PI)/(25/180*Math.PI), 2)));
      return Math.sqrt(Math.pow(DeltaL/kL/SL, 2) + Math.pow(DeltaC/kC/SC, 2) + Math.pow(DeltaH/kH/SH, 2) + RT*DeltaC/kC/SC*DeltaH/kH/SH);
    }

    function searchColorId(src) {
      let colorID = [];
      for (let i = 0; i < src.data.length; i += 4) {
        // src.data[i];
        // src.data[i + 1];
        // src.data[i + 2];
        // src.data[i + 3];
         colorID.push(colorMap.reduce((previous, current, index) => {
          let d = CIE2000(RGB2LAB([src.slice(i, i + 3)]), RGB2LAB[colorID[index]]);
          return previous[1] > d ? [index, d] : previous;
        }, [-1, 9999]));
      }
      return colorID;
    }

    function dragOverHandlerNBT(ev) {
      console.log('File(s) in drop zone');

      // Prevent default behavior (Prevent file from being opened)
      ev.preventDefault();
    }
  
    function dragOverHandlerImage(ev) {
      console.log('File(s) in drop zone');

      // Prevent default behavior (Prevent file from being opened)
      ev.preventDefault();
    }

    let src_map_data = null;
    let nbt_map_data = null;
    let nbt_name = "";

    function dropHandlerNBT(ev) {
      console.log('File(s) dropped');

      ev.preventDefault();

      if (ev.dataTransfer.items) {
        for (let i = 0; i < ev.dataTransfer.items.length; i++) {
          if (ev.dataTransfer.items[i].kind === 'file') {
            let item = ev.dataTransfer.items[i];
            console.log(item );
            // console.log("type : " + item.type);
            let reader = new FileReader();
            let file = item.getAsFile();
            nbt_name = file.name;
            reader.readAsArrayBuffer(file);
            reader.onload = function() {
              nbt_map_data = new Promise( (resolve, reject) => {return resolve(reader.result)})
              .then((e) => new Uint8Array(e))
              .then((e) => new Zlib.Gunzip(e))
              .then((e) => e.decompress())
              .then((e) => nbt2json(e))
              .then((e) => {
                const tree = jsonview.create(e[0]);
                jsonview.render(tree, document.getElementById("nbt_zone"));
                jsonview.expand(tree);
                document.getElementById("nbt_zone").style.height = window.getComputedStyle(document.getElementsByClassName("json-container")[0]).getPropertyValue('height');
                // console.log(document.getElementsByClassName("json-container")[0]);
                console.log(window.getComputedStyle(document.getElementsByClassName("json-container")[0]).getPropertyValue('height'));
                // document.getElementById("nbt_zone").innerHTML = JSON.stringify(e[0]);
                return e[0];
              });
              console.log(nbt_map_data);
            };
          }
        }
      } else {
        for (let i = 0; i < ev.dataTransfer.files.length; i++) {
          console.log('... file[' + i + '].name = ' + ev.dataTransfer.files[i].name);
        }
      }

      // Pass event to removeDragData for cleanup
      removeDragData(ev)
    }

    function dropHandlerImage(ev) {
      console.log('File(s) dropped');

      ev.preventDefault();

      if (ev.dataTransfer.items) {
        for (let i = 0; i < ev.dataTransfer.items.length; i++) {
          if (ev.dataTransfer.items[i].kind === 'file') {
            let item = ev.dataTransfer.items[i];
            // console.log('... file[' + i + '].name = ' + item.name );
            console.log("type : " + item.type);
            if (item.type.match("^image/png")) {
              
              const canvas = document.getElementById("canvas");
              let ctx = canvas.getContext("2d");
              let image = new Image();

              let reader = new FileReader();
              reader.readAsDataURL(item.getAsFile());
              console.log(item.getAsFile().arrayBuffer());
              reader.onload = function() {
                image.src = reader.result;
                console.log(image.src);
              };

              image.onload = function() {
                console.log("load");
                let canvasStyle = document.querySelector('#canvas');
                canvasStyle.width = document.documentElement.clientWidth*0.7;
                canvasStyle.height = canvasStyle.width*image.height/image.width;
                ctx.width = image.width;
                ctx.height = image.height;
                ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvasStyle.width, canvasStyle.width*image.height/image.width);
                // console.log(canvas.toDataURL('image/png'));
                src_map_data = searchColorId(ctx.getImageData(0, 0, image.width, image.height));
                // console.log(src_map_data);
              };
            } else {

            }
          }
        }
      } else {
        // Use DataTransfer interface to access the file(s)
        for (let i = 0; i < ev.dataTransfer.files.length; i++) {
          console.log('... file[' + i + '].name = ' + ev.dataTransfer.files[i].name);
        }
      }

      // Pass event to removeDragData for cleanup
      removeDragData(ev)
    }

    function removeDragData(ev) {
      console.log('Removing drag data')

      if (ev.dataTransfer.items) {
        // Use DataTransferItemList interface to remove the drag data
        ev.dataTransfer.items.clear();
      } else {
        // Use DataTransfer interface to remove the drag data
        ev.dataTransfer.clearData();
      }
    }
//Big Endiannes
    function nbt2json(nbtarray, tagid=null) {
      // console.log(nbtarray);
      let i = 0, name, len, tmp, taglen;
      let data = {};
      while(tagid===null || (tagid!==null && n==0)) {
        // console.log(i);
        if (nbtarray[i]===undefined) return [null, -1];
        switch (tagid===null ? nbtarray[i] : tagid) {
          case 0 :
            i++;
            // console.log("f");
            return [data, i];
            // break;
          case 1 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            tmp = nbtarray[i + taglen + len];
            name = new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            if (tagid === null) {
              data[name] = {
                type: 1,
                name: name,
                // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
                data: nbtarray[i + taglen + len] & 0b1000000 ? -0x0100 + tmp : tmp,
                binary: nbtarray.slice(i, i + taglen + 1 + len)
              };
            } else {
              data = {
                data: nbtarray[i + taglen + len] & 0b1000000 ? -0x0100 + tmp : tmp,
                binary: nbtarray.slice(i, i + taglen + 1 + len)
              };
            }
            i = i + taglen + 1 + len;
            break;
          case 2 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            tmp = nbtarray[i + taglen + len] << 8 + nbtarray[i + taglen + 1 + len];
            name = new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            if (tagid === null) {
              data[name] = {
                type: 2,
                name: name,
                // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
                data: nbtarray[i + taglen + len] & 0b1000000 ? -0b010000 + tmp : tmp,
                binary: nbtarray.slice(i, i + taglen + 2 + len)
              };
            } else {
              data = {
                data: nbtarray[i + taglen + len] & 0b1000000 ? -0b010000 + tmp : tmp,
                binary: nbtarray.slice(i, i + taglen + 2 + len)
              };
            }
            i = i + taglen + 2 + len;
            break;
          case 3 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            tmp = nbtarray[i + taglen + len] << 24 + nbtarray[i + taglen + 1 + len] << 16 + nbtarray[i + taglen + 2 + len] << 8 + nbtarray[i + taglen + 3 + len];
            name = new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            if (tagid === null) {
              data[name] = {
                type: 3,
                name: name,
                // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
                data: nbtarray[i + taglen + len] & 0b1000000 ? -0b0100000000 + tmp : tmp,
                binary: nbtarray.slice(i, i + taglen + 4 + len)
              };
            } else {
              data = {
                data: nbtarray[i + taglen + len] & 0b1000000 ? -0b0100000000 + tmp : tmp,
                binary: nbtarray.slice(i, i + taglen + 4 + len)
              };
            }
            i = i + taglen + 4 + len;
            break;
          case 4 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            tmp = nbtarray[i + taglen + len] << 56 + nbtarray[i + taglen + 1 + len] << 48 + nbtarray[i + taglen + 2 + len] << 40 + nbtarray[i + taglen + 3 + len] << 32 + nbtarray[i + taglen + 4 + len] << 24 + nbtarray[i + taglen + 5 + len] << 16 + nbtarray[i + taglen + 6 + len] << 8 + nbtarray[i + taglen + 7 + len];
            name = new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            if (tagid === null) {
              data[name] = {
                type: 4,
                name: name,
                // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
                data: nbtarray[i + taglen + len] & 0b1000000 ? -0b010000000000000000 + tmp : tmp,
                binary: nbtarray.slice(i, i + taglen + 8 + len)
              };
            } else {
              data = {
                data: nbtarray[i + taglen + len] & 0b1000000 ? -0b010000000000000000 + tmp : tmp,
                binary: nbtarray.slice(i, i + taglen + 8 + len)
              };
            }
            i = i + taglen + 8 + len;
            break;
          case 5 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            name = new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            if (tagid === null) {
              data[name] = {
                type: 5,
                name: name,
                // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
                data: (nbtarray[i + taglen + len] & 0b10000000 ? -1 : 1)*Math.exp(2, (nbtarray[i + taglen + len] & 0b01111111) << 1 + nbtarray[i + taglen + 1 + len] >> 7 - 140)*(1 << 23 + (nbtarray[i + taglen + 1 + len] & 0b01111111) << 16 + nbtarray[i + taglen + 2 + len] << 8 + nbtarray[i + taglen + 3 + len]),
                binary: nbtarray.slice(i, i + taglen + 4 + len)
              };
            } else {
              data = {
                data: (nbtarray[i + taglen + len] & 0b10000000 ? -1 : 1)*Math.exp(2, (nbtarray[i + taglen + len] & 0b01111111) << 1 + nbtarray[i + taglen + 1 + len] >> 7 - 140)*(1 << 23 + (nbtarray[i + taglen + 1 + len] & 0b01111111) << 16 + nbtarray[i + taglen + 2 + len] << 8 + nbtarray[i + taglen + 3 + len]),
                binary: nbtarray.slice(i, i + taglen + 4 + len)
              };
            }
            i = i + taglen + 4 + len;
            break;
          case 6 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            name = new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            if (tagid === null) {
              data[name] = {
                type: 6,
                name: name,
                // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
                data: (nbtarray[i + taglen + len] & 0b10000000 ? -1 : 1)*Math.exp(2, (nbtarray[i + taglen + len] & 0b01111111) << 4 + nbtarray[i + taglen + 1 + len] >> 4 - 1079)*(1 << 52 + (nbtarray[i + taglen + 1 + len] & 0b00001111) << 48 + nbtarray[i + taglen + 2 + len] << 40 + nbtarray[i + taglen + 3 + len] << 32 + nbtarray[i + taglen + 4 + len] << 24 + nbtarray[i + taglen + 5 + len] << 16 + nbtarray[i + taglen + 6 + len] << 8 + nbtarray[i + taglen + 7 + len]),
                binary: nbtarray.slice(i, i + taglen + 8 + len)
              };
            } else {
              data = {
                data: (nbtarray[i + taglen + len] & 0b10000000 ? -1 : 1)*Math.exp(2, (nbtarray[i + taglen + len] & 0b01111111) << 4 + nbtarray[i + taglen + 1 + len] >> 4 - 1079)*(1 << 52 + (nbtarray[i + taglen + 1 + len] & 0b00001111) << 48 + nbtarray[i + taglen + 2 + len] << 40 + nbtarray[i + taglen + 3 + len] << 32 + nbtarray[i + taglen + 4 + len] << 24 + nbtarray[i + taglen + 5 + len] << 16 + nbtarray[i + taglen + 6 + len] << 8 + nbtarray[i + taglen + 7 + len]),
                binary: nbtarray.slice(i, i + taglen + 8 + len)
              };
            }
            i = i + taglen + 8 + len;
            break;
          case 7 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            tmp = nbtarray[i + taglen + len] << 24 + nbtarray[i + taglen + 1 + len] << 16 + nbtarray[i + taglen + 2 + len] << 8 + nbtarray[i + taglen + 3 + len];
            name = new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            if (tagid === null) {
              data[name] = {
                type: 7,
                name: name,
                // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
                data: nbtarray.slice(i + taglen + 4 + len, i + taglen + 4 + len + tmp),
                binary: nbtarray.slice(i, i + taglen + 4 + len + tmp)
              };
            } else {
              data = {
                data: nbtarray.slice(i + taglen + 4 + len, i + taglen + 4 + len + tmp),
                binary: nbtarray.slice(i, i + taglen + 4 + len + tmp)
              };
            }
            i = i + taglen + 4 + len + tmp;
            break;
          case 8 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            tmp = nbtarray[i + taglen + len] << 8 + nbtarray[i + taglen + 1 + len];
            name = new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            if (tagid === null) {
              data[name] = {
                type: 8,
                name: name,
                // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
                data: new TextDecoder().decode(nbtarray.slice(i + taglen + 2 + len, i + taglen + 2 + len + tmp)),
                // data: nbtarray.slice(i + taglen + 2 + len, i + taglen + 2 + len + tmp).toString(),
                binary: nbtarray.slice(i, i + taglen + 2 + len + tmp)
              };
            } else {
              data = {
                data: new TextDecoder().decode(nbtarray.slice(i + taglen + 2 + len, i + taglen + 2 + len + tmp)),
                binary: nbtarray.slice(i, i + taglen + 2 + len + tmp)
              };
            }
            i = i + taglen + 2 + len + tmp;
            break;
          case 9 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            tmp = new Array(0);
            let count = nbtarray[i + taglen+ 1 + len ] << 24 + nbtarray[i + taglen + 2 + len] << 16 + nbtarray[i + taglen + 3 + len] << 8 + nbtarray[i + taglen + 4 + len];
            let redata = [null, 0];
            let listcount = 0;
            let tagid = nbtarray[i + taglen + len];
            for (let j = 0; j < count; j++) {
              redata = nbt2json(nbtarray.slice(i + taglen + len + 5 + listcount), tagid);
              listcount += redata[1];
              tmp.push(redata[0]);
            }
            name = new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            data[name] = {
              type: 10,
              name: name,
              // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
              data: tmp,
              binary: nbtarray.slice(i, i + taglen + len + 5)
            };
            i = i + taglen + len + 5 + listcount;
            break;
          case 10 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            tmp = nbt2json(nbtarray.slice(i + taglen + len));
            if (tmp[0] == null) return tmp;
            name = len == 0 ? "" : new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            data[name] = {
              type: 10,
              name: name,
              // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
              data: tmp[0],
              binary: nbtarray.slice(i, i + taglen + len)
            };
            i = i + taglen + len + tmp[1];
            break;
          case 11 :
            taglen = tagid===null ? 3 : 0
            len = tagid===null ? nbtarray[i + 1] << 8 | nbtarray[i + 2] : 0;
            tmp = nbtarray[i + taglen + len] << 24 + nbtarray[i + taglen + 1 + len] << 16 + nbtarray[i + taglen + 2 + len] << 8 + nbtarray[i + taglen + 3 + len];
            name = new TextDecoder().decode(nbtarray.slice(i + taglen, i + taglen + len));
            if (tagid === null) {
              data[name] = {
                type: 11,
                name: name,
                // name: nbtarray.slice(i + taglen, i + taglen + len).toString(),
                data: (new Array(tmp)).map((element, index) => nbtarray[i + taglen + 4 + len + index*4] << 24 + nbtarray[i + taglen + 5 + len + index*4] << 16 + nbtarray[i + taglen + 6 + len + index*4] << 8 + nbtarray[i + taglen + 7 + len + index*4]),
                binary: nbtarray.slice(i, i + taglen + 4 + len + tmp*4)
              };
            } else {
              data = {
                data: (new Array(tmp)).map((element, index) => nbtarray[i + taglen + 4 + len + index*4] << 24 + nbtarray[i + taglen + 5 + len + index*4] << 16 + nbtarray[i + taglen + 6 + len + index*4] << 8 + nbtarray[i + taglen + 7 + len + index*4]),
                binary: nbtarray.slice(i, i + taglen + 4 + len + tmp*4)
              };
            }
            i = i + taglen + 4 + len + tmp*4;
        }
      }
      return [data, i];
    }

    function json2nbt(jsondata) {
      let data = Object.keys(jsondata).reduce((previous, current, index) => {
        if (jsondata[current].type == 10 || jsondata[current].type == 9) {
          return previous.concat(json2nbt(jsondata[current].data));
        } else {
          return previous.concat(jsondata[current].binary);
        }
      });
      return data.concat([0]);
    }

//     let crc_table = new Uint32Array(256);

//     let crc_table_computed = 0;

//     function make_crc_table() {
//       let c = 0n;
//       let n, k;
//       for (n = 0; n < 256; n++) {
//         c = n;
//         for (k = 0; k < 8; k++) {
//           if (c & 1) {
//             c = 0xedb88320n ^ (c >> 1);
//           } else {
//             c = c >> 1;
//           }
//         }
//         crc_table[n] = c;
//       }
//       crc_table_computed = 1;
//     }

//     function update_crc(crc, buf, len) {
//       c = crc ^ 0xffffffffn;
//       let n;

//       if (!crc_table_computed)
//         make_crc_table();
//       for (n = 0; n < len; n++) {
//         c = crc_table[(c ^ buf[n]) & 0xff] ^ (c >> 8);
//       }
//       return c ^ 0xffffffffn;
//     }

//     function crc(buf, len) {
//       return update_crc(0n, buf, len);
//     }
// // little endiannes
//     function gunzip(binary) {
//       let ID1 = binary[0];
//       let ID2 = binary[1];
//       let CM = binary[2];
//       let FLG = binary[3];
//       let MTIME = binary[4] << 3 | binary[5] << 2 | binary[6] << 1 | binary[7];
//       let XFL = binary[8];
//       let OS = binary[9];
//       if (ID1 !== 0x1F) return [null, "ID1"];
//       if (ID2 !== 0x8B) return [null, "ID2"];
//       if (!(CM & (1 << 7))) return [null, "CM"];
//       let FTEXT = FLG & 1;
//       let FHCRC = FLG & (1 << 1);
//       let FEXTRA = FLG & (1 << 2);
//       let FNAME = FLG & (1 << 3);
//       let FCOMMENT = FLG & (1 << 4);
//       if (FLG & (0b111 << 5)) return [null, "FLG RESERVED"];
//       let crcBuf = FHCRC ? binary.slice(0, 10) : null;
//       binary = binary.slice(10);
//       let exFeild = FEXTRA ? () => {
//         let tmp = binary.slice(1, binary[0] + 1);
//         if (FHCRC) crcBuf = crcBuf.concat(binary.slice(0, binary[0] + 1));
//         binary = binary.slice(binary[0] + 1);
//         // return [new TextDecoder().decode(tmp[0]), new TextDecoder().decode(tmp[1]), new TextDecoder().decode(tmp.slice(4, (tmp[2] << 8) | tmp[3] + 4))];
//         return [[tmp[0]].toString(), [tmp[1]].toString(), tmp.slice(4, (tmp[3] << 8) | tmp[2] + 4).toString()];
//       } : null;
//       let fileName = FNAME ? () => {  //  it may be good way to change other way to get strings and the length;
//         let tmp = "";
//         for (let i = 0; binary[i] !== 0; i++) {
//           // tmp +=  new TextDecoder().decode(binary[i]);
//           tmp += binary[i].toString();
//         }
//         if (FHCRC) crcBuf = crcBuf.concat(binary.slice(0, tmp.length));
//         binary = binary.slice(tmp.length);
//         return tmp;
//       } : null;
//       let fileComment = FCOMMENT ? () => {  //  -------------------------------------------------------
//         let tmp = "";
//         for (let i = 0; binary[i] !== 0; i++) {
//           // tmp +=  new TextDecoder().decode(binary[i]);
//           tmp += binary[i].toString();
//         }
//         if (FHCRC) crcBuf = crcBuf.concat(binary.slice(0, tmp.length));
//         binary = binary.slice(tmp.length);
//         return tmp;
//       } : null;
//       if (FHCRC) {
//         let tmp = update_crc(binary[1] << 8 | binary[0] ,crcBuf, crcBuf.length);
//         if (tmp & 0xffff !== 0) return [null, "CRC16"];
//         binary = binary.slice(2);
//       }
//       let previous;
//       do {
//         let BFINAL = (binary[0] & 0b10000000) >> 7;
//         let BTYPE = (binary[0] & 0b01100000) >> 5;
//         if (BTYPE == 0) {
//           if (((binary[1] << 8 | binary[0]) + (binary[2] << 8 | binary[3])) & 0xFFFF !== 0) return [null, "LEN NLEN"];//error
//           previous = binary.slice(4, 4 + (binary[1] << 8 | binary[0]));
//           binary = binary.slice(4 + (binary[1] << 8 | binary[0]));
//         } else if (BTYPE == 0b01 || BTYPE == 0b10) {
//           if (BTYPE == 0b10) {

//           }
//         } else {
//           // error
//         }
//       } while(1);
//     }

    document.getElementById("download_button").onclick = (evt) => {

      if (nbt_map_data  && src_map_data) {
        nbt_map_data.data.colors = src_map_data;  // 128*128
        nbt_map_data.data.locked = 1;
        nbt_map_data.data.dimension = 127;
      }

      let zip = new Zlib.Gzip(nbt2json(nbt_map_data));
      let compressData = zip.compress();

      if (window.navigator.msSaveBlob) console.log("msSaveBlob");

      let blob = new Blob([compressData], { 'type': 'type/' });
      document.getElementById("download_button").download = nbt_name;
      document.getElementById("download_button").href = URL.createObjectURL(blob);
    }
  </script>
</body>
</html>

